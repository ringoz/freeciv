#!/bin/bash

# Using absolute paths due to bug in Inkscape on macOS
files="$(pwd)/$@"

if test "x$1" = "x-h" || test "x$1" = "x--help" ; then
    echo "Usage: $(basename $0) [list of svg-files]"
    exit 0
fi

# Renderer: inkscape or sodipodi.  Inkscape seems slightly better.
#SODIPODI="sodipodi"
RENDERER="inkscape -D"

# Target width: 29px is regular, 44px is large (height is then calculated
# automatically).
TARGET_WIDTH=58
TARGET_WIDTH_LARGE=88

SHIELD_WIDTH=28
SHIELD_HEIGHT=28
SHIELD_WIDTH_LARGE=38
SHIELD_HEIGHT_LARGE=38

which $RENDERER >/dev/null \
  || (echo "You need $RENDERER to render the SVG files.")
(which convert >/dev/null && which composite >/dev/null) \
  || (echo "You need ImageMagick to manipulate the images."; err=yes)

for file0 in $files; do
  # Generate the regular images
  filebase=`echo $file0 | sed 's/.[Ss][Vv][Gg]$//'`

  file1="$filebase-1.png"
  file2="$filebase-2.png"
  file3="$filebase-3.png"
  file4="$filebase@2x.png"
  echo "Converting $file0 to $file4"

  # This is actually necessary for rendering
  rm -f $file1 $file2 $file3 $file4

  $RENDERER -f "$file0" -w $(($TARGET_WIDTH - 4)) -e "$file1" >/dev/null

  # Ugly way to determine width and height.  There must be a better way!
  SIZE=`identify "$file1" | sed "s/^.*PNG //" | sed "s/ .*\$//"`
  WIDTH=`echo $SIZE | sed "s/x.*\$//"`
  HEIGHT=`echo $SIZE | sed "s/^.*x//"`

  # This complicated code puts a 1-pixel black border around the image.
  convert -resize $((2*$WIDTH))x$((2*$HEIGHT)) -fill black -draw "rectangle 0,0 $((2*$WIDTH)),$((2*$HEIGHT))" $file1 $file2
  convert -crop $((4+$WIDTH))x$((4+$HEIGHT))+0x0 $file2 $file3
  composite -gravity center -compose src-over $file1 $file3 $file4

  rm -f $file1 $file2 $file3 "$filebase-4-fs8.png"

  file1="$filebase-1.png"
  file2="$filebase-2.png"
  file3="$filebase-3.png"
  file4="$filebase-shield@2x.png"

  WIDTH=$(($SHIELD_WIDTH-4))
  HEIGHT=$(($SHIELD_HEIGHT-4))

  $RENDERER -f $file0 -h $HEIGHT -e $file1 > /dev/null

  composite -gravity center -compose src-over $file1 mask@2x.png $file2
  composite -gravity center -compose src-over mask@2x.png $file2 $file3
  convert -transparent magenta $file3 $file4

  rm -f $file1 $file2 $file3 "$filebase-4-fs8.png"

  # Generate the large images
  filebase=`echo $file0 | sed 's/.[Ss][Vv][Gg]$//'`

  file1="$filebase-1.png"
  file2="$filebase-2.png"
  file3="$filebase-3.png"
  file4="$filebase-large@2x.png"
  echo "Converting $file0 to $file4"

  # This is actually necessary for rendering
  rm -f $file1 $file2 $file3 $file4

  $RENDERER -f "$file0" -w $(($TARGET_WIDTH_LARGE - 4)) -e "$file1" >/dev/null

  # Ugly way to determine width and height.  There must be a better way!
  SIZE=`identify "$file1" | sed "s/^.*PNG //" | sed "s/ .*\$//"`
  WIDTH=`echo $SIZE | sed "s/x.*\$//"`
  HEIGHT=`echo $SIZE | sed "s/^.*x//"`

  # This complicated code puts a 1-pixel black border around the image.
  convert -resize $((2*$WIDTH))x$((2*$HEIGHT)) -fill black -draw "rectangle 0,0 $((2*$WIDTH)),$((2*$HEIGHT))" $file1 $file2
  convert -crop $((4+$WIDTH))x$((4+$HEIGHT))+0x0 $file2 $file3
  composite -gravity center -compose src-over $file1 $file3 $file4

  rm -f $file1 $file2 $file3 "$filebase-4-fs8.png"

  file1="$filebase-1.png"
  file2="$filebase-2.png"
  file3="$filebase-3.png"
  file4="$filebase-shield-large@2x.png"

  WIDTH=$(($SHIELD_WIDTH_LARGE-4))
  HEIGHT=$(($SHIELD_HEIGHT_LARGE-4))

  $RENDERER -f $file0 -h $HEIGHT -e $file1 > /dev/null

  composite -gravity center -compose src-over $file1 mask-large@2x.png $file2
  composite -gravity center -compose src-over mask-large@2x.png $file2 $file3
  convert -transparent magenta $file3 $file4

  rm -f $file1 $file2 $file3 "$filebase-4-fs8.png"
done
